// SPDX-License-Identifier: Apache-2.0
// Copyright Â© 2024 The Whixy Authors. All rights reserved.
// Contributors responsible for this file:
// @p7r0x7 <mattrbonnette@pm.me>

RUNE              <rune>              => lookup();
FLOAT             <float>             => lookup();
INTEGER           <integer>           => lookup();
IDENTIFIER        <identifier>        => lookup();
BACKSLASHSTRING   <backSlashString>   => lookup();
DOUBLEQUOTESTRING <doubleQuoteString> => lookup();

// lower precedence
{ OR                                                                                } <<
{ AND                                                                               } <<
{ EQUAL_EQUALS TILDE_EQUALS LESSTHAN GREATERTHAN LESSTHAN_EQUALS GREATERTHAN_EQUALS } <<
{ PLUS HYPHEN PIPE CARROT PLUS_PERCENT HYPHEN_PERCENT                               } <<
{ ASTERISK SLASH PERCENT AMPERSAND LESSTHAN_LESSTHAN GREATERTHAN_GREATERTHAN
  ASTERISK_PERCENT LESSTHAN_LESSTHAN_PERCENT GREATERTHAN_GREATERTHAN_PERCENT        } <<
// higher precendence

srcFile: (routineDecl | valueDecl)+ <eof>;

stmt
    : call
    | methodCall
    | assignStmt
    | valueDecl
    | routineDecl
    | returnStmt
    | ifStmt
    | whereStmt
    | whileStmt
    | forStmt
    | comptStmt
    | unreachable
    | deferStmt
    | errdeferStmt;

assignStmt: atom assignOp atom;
assignOp
    : AMPERSAND_EQUALS                       # andEqualsOp
    | PIPE_EQUALS                            # orEqualsOp
    | PERCENT_EQUALS                         # modEqualsOp
    | CARROT_EQUALS                          # xorEqualsOp
    | SLASH_EQUALS                           # divideEqualsOp
    | PLUS_EQUALS                            # addEqualsOp
    | HYPHEN_EQUALS                          # subEqualsOp
    | ASTERISK_EQUALS                        # timesEqualsOp
    | LESSTHAN_LESSTHAN_EQUALS               # leftShiftEqualsOp
    | GREATERTHAN_GREATERTHAN_EQUALS         # rightShiftEqualsOp
    | ASTERISK_PERCENT_EQUALS                # wrappingTimesEqualsOp
    | PLUS_PERCENT_EQUALS                    # wrappingAddEqualsOp
    | HYPHEN_PERCENT_EQUALS                  # wrappingSubEqualsOp
    | GREATERTHAN_GREATERTHAN_PERCENT_EQUALS # rightRotateEqualsOp
    | LESSTHAN_LESSTHAN_PERCENT_EQUALS       # leftRotateEqualsOp; // TODO(@p7r0x7): Needs reordering.

call: atom (atom+ | expr);

blockStmt:    (OPENPARENTHESIS | dollarOPENPARENTHESIS) (stmt (stmtSep stmt)*)? CLOSEPARENTHESIS;
dollarOPENPARENTHESIS: DOLLAR_OPENPARENTHESIS;

routineStmt: inline? (fast | bare)? typeExpr token structExpr blockStmt;
inline:      INLINE;
fast:        FAST;
bare:        BARE;

returnStmt: RETURN (atom+ | expr);

ifStmt: IF atom stmt (ELSEIF atom stmt)* (ELSE stmt)?;

whereStmt:     WHERE tuple comparisonOp? block FIN;
comparisonOp:  ;
caseStmtBlock: ;

loopStmt: unroll? (while | for) atom? atom? stmt;
unroll:   UNROLL;
while:    WHILE;
for:      FOR;

comptStmt: COMPT stmt;

unreachable: UNREACHABLE;

deferStmt: DEFER stmt;

errdeferStmt: ERRDEFER stmt;

//
//    Expressions
//

exprSep: COMMA | NEWLINE;
expr
    : field
    | typeExpr
    | call
    | binaryExpr
    | postExpr
    | preExpr
    | ifExpr
    | whereExpr
    | comptExpr
    | unreachable
    | routineExpr
    | string
    | rune
    | atom;

typeExpr:   underscore | pointer? this | atom;
underscore: UNDERSCORE;
pointer:    ASTERISK;
this:       THIS;

binaryExpr
    : atom (
        asOp
        | (
            timesOp
            | divideOp
            | modOp
            | bitwiseAndOp
            | leftShiftOp
            | rightShiftOp
            | wrappingTimesOp
            | leftRotateOp
            | rightRotateOp
        )
        | (addOp | subOp | bitwiseOrOp | xorOp | wrappingAddOp | wrappingSubOp)
        | (
            equalityOp
            | inequalityOp
            | lessThanOp
            | greaterThanOp
            | lessThanOrEqualToOp
            | greaterThanOrEqualToOp
        )
        | logicalAndOp
        | logicalOrOp
    ) atom;
asOp:                   AS;
concatOp:               PLUS_PLUS;
repeatOp:               ASTERISK_ASTERISK;
addOp:                  PLUS;
subOp:                  HYPHEN;
timesOp:                ASTERISK;
divideOp:               SLASH;
lessThanOp:             LESSTHAN;
greaterThanOp:          GREATERTHAN;
lessThanOrEqualToOp:    LESSTHAN_EQUALS;
greaterThanOrEqualToOp: GREATERTHAN_EQUALS;
wrappingAddOp:          PLUS_PERCENT;
wrappingSubOp:          HYPHEN_PERCENT;
wrappingTimesOp:        ASTERISK_PERCENT;
leftShiftOp:            LESSTHAN_LESSTHAN;
rightShiftOp:           GREATERTHAN_GREATERTHAN;
leftRotateOp:           LESSTHAN_LESSTHAN_PERCENT;
rightRotateOp:          GREATERTHAN_GREATERTHAN_PERCENT;
equalityOp:             EQUAL_EQUALS;
inequalityOp:           TILDE_EQUALS;
logicalAndOp:           AND;
logicalOrOp:            OR;
bitwiseAndOp:           AMPERSAND;
bitwiseOrOp:            PIPE;
modOp:                  PERCENT;
xorOp:                  CARROT;

postExpr: atom postOp;
postOp
    : DOT atom                                        # accessMemberOp
    | OPENBRACKET expr CLOSEBRACKET # accessIndexOp
    | DOT TYPE                                        # accessTypeOp
    | DOT LEN                                         # accessLengthOp
    | DOT ASTERISK                                    # dereferencePointerOp
    | DOT AMPERSAND                                   # addressOfOp
    | QUESTION                                        # unwrapOptionalOp
    | EXCLAMATION                                     # tryOp;

preExpr: preOp atom;
preOp:   TILDE # notOp | HYPHEN # negateOp;

ifExpr: IF atom expr (ELSEIF atom expr)* (ELSE expr)?;

whereExpr:     WHERE atom comparisonOp caseExprBlock;
caseExprBlock: ;

comptExpr: COMPT expr;

routineExpr: inline? (fast | bare)? typeExpr structExpr blockStmt;

string: DOUBLEQUOTESTRING # dQString | BACKSLASHSTRING # bSString | BACKTICKSTRING # bTString;

rune: SINGLEQUOTE token SINGLEQUOTE;

atom: token | tupleExpr | blockExpr | structExpr;

token: TOKEN;

tupleExpr: OPENPARENTHESIS (expr (exprSep expr)*)? CLOSEPARENTHESIS;

blockExpr: OPENPARENTHESIS ((stmt (stmtSep stmt)* stmtSep)? expr)? CLOSEPARENTHESIS;

struct:   OPENBRACE (field | routineDecl | valueDecl)+ CLOSEBRACE;
field:    MUT? VOLATILE? THREADL? atom token+ (EQUAL expr)?;

/*
DOUBLEQUOTESTRING: '"' ('\\"' | ~["])* '"';                                // NB: separate tokens saves work
BACKTICKSTRING:    '`' ('\\`' | ~[`])* '`';                                // NB: separate tokens saves work
BACKSLASHSTRING:   (WHITESPACE? '\\ ' ~[\r\n]* [\r\n])+;                   // TODO(@p7r0x7): missing predicate
BLOCKDOCCOMMENT:   (WHITESPACE? '##' ~[\r\n]* [\r\n])+ -> channel(HIDDEN); // TODO(@p7r0x7): missing predicate
BLOCKCOMMENT:      (WHITESPACE? '#' ~[\r\n]* [\r\n])+ -> channel(HIDDEN);  // TODO(@p7r0x7): missing predicate
DOCCOMMENT:        '##' ~[\r\n]* -> channel(HIDDEN);
COMMENT:           '#' ~[\r\n]* -> channel(HIDDEN);
WHITESPACE:        [ \t]+ -> channel(HIDDEN);
NEWLINE:           [\r\n]+;

OPENPARENTHESIS:        '(';  // open group expression
CLOSEPARENTHESIS:       ')';  // close group expression
DOT:                    '.';  // postfix op: access field (after DOT...)
COMMA:                  ',';  // expression separator
UNDERSCORE:             '_';  // type inferrence directive or
EXCLAMATION:            '!';  // infix op: logical NOT; bitwise NOT (after EXCLAMATION...)
OPENBRACE:              '{';  // open type expression
CLOSEBRACE:             '}';  // close type expression
OPENBRACKET:            '[';  // open indexing expression
CLOSEBRACKET:           ']';  // close indexing expression
SEMICOLON:              ';';  // statement separator
QUESTION:               '?';  // postfix op: explicitly unwrap optional
DOLLAR_OPENPARENTHESIS: '$('; //
SINGLEQUOTE:            '\''; //

GREATERTHAN_GREATERTHAN_PERCENT_EQUALS: '>>%='; // combined assignment: rotr
GREATERTHAN_GREATERTHAN_PERCENT:       '>>%';  //
GREATERTHAN_GREATERTHAN_EQUALS:         '>>=';  // combined assignment: right shift
GREATERTHAN_GREATERTHAN:               '>>';   //
GREATERTHAN_EQUALS:                     '>=';   // infix op: greater than or equal to comparison
GREATERTHAN:                           '>';    // infix op: greater than comparison
LESSTHAN_LESSTHAN_PERCENT_EQUALS:       '<<%='; // combined assignment: rotl
LESSTHAN_LESSTHAN_PERCENT:             '<<%';  // rotl
LESSTHAN_LESSTHAN_EQUALS:               '<<=';  // combined assignment: left shift
LESSTHAN_LESSTHAN:                     '<<';   // left shift
LESSTHAN_EQUALS:                        '<=';   // infix op: less than or equal to comparison
LESSTHAN:                              '<';    // infix op: less than comparison
ASTERISK_PERCENT_EQUALS:                '*%=';  // combined wrapping assignment: multiplication
ASTERISK_PERCENT:                      '*%';   //
ASTERISK_EQUALS:                        '*=';   // combined assignment: multiplication
ASTERISK_ASTERISK:                     '**';   // infix op: comptime value repetition
ASTERISK:                              '*';    // (after ASTERISK...)
PLUS_PERCENT_EQUALS:                    '+%=';  // combined wrapping assignment: addition
PLUS_PERCENT:                          '+%';   //
PLUS_EQUALS:                            '+=';   // combined assignment: addition
PLUS_PLUS:                             '++';   // infix op: comptime value concatenation
PLUS:                                  '+';    // infix op: addition (after PLUS...)
HYPHEN_PERCENT_EQUALS:                   '-%=';  // combined wrapping assignment: subtraction
HYPHEN_PERCENT:                         '-%';   //
HYPHEN_EQUALS:                           '-=';   // combined assignment: subtraction
HYPHEN:                                 '-';    // infix op: subtraction; prefix: negation (after HYPHEN...)
TILDE_EQUALS:                           '~=';   // infix op: inequality comparison
TILDE:                                 '~';    // infix op: logical NOT; bitwise NOT (after EXCLAMATION...)
AMPERSAND_EQUALS:                       '&=';   // combined assignment: bitwise AND
AMPERSAND:                             '&';    // infix op: logical AND; bitwise AND (after AMPERSAND...)
PERCENT_EQUALS:                         '%=';   // combined assignment: modulus
PERCENT:                               '%';    // (after PERCENT...)
CARROT_EQUALS:                          '^=';   // combined assignment: bitwise XOR
CARROT:                                '^';    // infix op: logical XOR bitwise XOR (after CARROT...)
SLASH_EQUALS:                           '/=';   // combined assignment: division
SLASH:                                 '/';    // (after SLASH...)
EQUAL_EQUALS:                           '==';   // infix op: equality comparison
EQUAL:                                 '=';    // infix op: assign type instance to value; declare default type instance of value (after EQUAL...)
PIPE_EQUALS:                            '|=';   // combined assignment: bitwise OR
PIPE:                                  '|';    // infix op: logical OR; bitwise OR; routine overloading (after PIPE...)

AND:         'and';         //
OR:          'or';          // logical or operator
TYPE:        'type';        // postfix: access comptime type
LEN:         'len';         // postfix: access length
THIS:        'this';        // immediately encapsulating type directive
MUT:         'mut';         // value mutability modifier
INLINE:      'inline';      // routine inlining modifier
RETURN:      'return';      // return statement
CONTINUE:    'continue';    // goto continue statement
BREAK:       'break';       // goto break statement
GOTO:        'goto';        // goto label statement
WHILE:       'while';       // while loop statement/expression
FOR:         'for';         // for loop statement/expression
IF:          'if';          // if statement statement/expression
ELSEIF:      'elseif';      // elseif statement/expression
ELSE:        'else';        // else statement/expression
WHERE:       'where';       // enhanced switch statement/expression
DEFER:       'defer';       // defer statement
ERRDEFER:    'errdefer';    // errdefer statement
FAST:        'fast';        // routine fastcall convention modifier
BARE:        'bare';        // routine freestanding convention modifier
IMPORT:      'import';      // import statement/expression
ALIGN:       'align';       // value alignment modifier
THREADL:     'threadl';     // value thread-local modifier
UNREACHABLE: 'unreachable'; // unreachable statement/expression
VOLATILE:    'volatile';    // value volatile modifier
UNROLL:      'unroll';      // loop inlining modifier
COMPT:       'compt';       // type/statement/expression comptime modifier
TEST:        'test';        // routine test modifier
ENUM:        'enum';        // enumeration type expression
EMBED:       'embed';       // disk data embed directive
UNION:       'union';       // union type expression
STD:         'std';         // standard library value
ORELSE:      'orelse';      // optional unwrapping operator
CATCH:       'catch';       // error handling operator
AS:          'as';          // coercion operator
*/
